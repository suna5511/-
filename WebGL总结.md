1.CPU和GPU的区别
  a. 
      CPU和GPU之所以大不相同，是由于其设计目标的不同，它们分别针对了两种不同的应用场景。CPU需要很强的通用性来处理各种不同的数据类型，同时又要逻辑判断又会引入大量的分支跳转和中断的处理。
    这些都使得CPU的内部结构异常复杂。而GPU面对的则是类型高度统一的、相互无依赖的大规模数据和不需要被打断的纯净的计算环境。
  b. 
      GPU采用了数量众多的计算单元和超长的流水线，但只有非常简单的控制逻辑并省去了Cache。而CPU不仅被Cache占据了大量空间，而且还有有复杂的控制逻辑和诸多优化电路，相比之下计算能力只是CPU
    很小的一部分。
      GPU是基于大的吞吐量设计。GPU的特点是有很多的ALU和很少的cache. 缓存的目的不是保存后面需要访问的数据的，这点和CPU不同，而是为thread提高服务的。如果有很多线程需要访问同一个相同的数据，
    缓存会合并这些访问，然后再去访问dram（因为需要访问的数据保存在dram中而不是cache里面），获取数据后cache会转发这个数据给对应的线程，这个时候是数据转发的角色。但是由于需要访问dram，自然
    会带来延时的问题。GPU的控制单元（左边黄色区域块）可以把多个的访问合并成少的访问。GPU的虽然有dram延时，却有非常多的ALU和非常多的thread. 为了平衡内存延时的问题，我们可以中充分利用多的
    ALU的特性达到一个非常大的吞吐量的效果。尽可能多的分配多的Threads.通常来看GPU ALU会有非常重的pipeline就是因为这样。所以与CPU擅长逻辑控制，串行的运算。和通用类型数据运算不同，GPU擅长
    的是大规模并发计算，这也正是密码破解等所需要的。所以GPU除了图像处理，也越来越多的参与到计算当中来。GPU的工作大部分就是这样，计算量大，但没什么技术含量，而且要重复很多很多次。就像你有
    个工作需要算几亿次一百以内加减乘除一样，最好的办法就是雇上几十个小学生一起算，一人算一部分，反正这些计算也没什么技术含量，纯粹体力活而已。而CPU就像老教授，积分微分都会算，就是工资高，
    一个老教授资顶二十个小学生，你要是富士康你雇哪个？GPU就是这样，用很多简单的计算单元去完成大量的计算任务，纯粹的人海战术。这种策略基于一个前提，就是小学生A和小学生B的工作没有什么依赖性，
    是互相独立的。很多涉及到大量计算的问题基本都有这种特性，比如你说的破解密码，挖矿和很多图形学的计算。这些计算可以分解为多个相同的简单小任务，每个任务就可以分给一个小学生去做。但还有一些
    任务涉及到“流”的问题。比如你去相亲，双方看着顺眼才能继续发展。总不能你这边还没见面呢，那边找人把证都给领了。这种比较复杂的问题都是CPU来做的。
  c. 
      CPU有强大的ALU（算术运算单元）,它可以在很少的时钟周期内完成算术计算。当今的CPU可以达到64bit双精度。执行双精度浮点源算的加法和乘法只需要1～3个时钟周期。CPU的时钟周期的频率是非常
   高的，达到1.532～3gigahertz(千兆HZ, 10的9次方).大的缓存也可以降低延时。保存很多的数据放在缓存里面，当需要访问的这些数据，只要在之前访问过的，如今直接在缓存里面取即可。复杂的逻辑
   控制单元。当程序含有多个分支的时候，它通过提供分支预测的能力来降低延时。数据转发。 当一些指令依赖前面的指令结果时，数据转发的逻辑控制单元决定这些指令在pipeline中的位置并且尽可能快的
   转发一个指令的结果给后续的指令。这些动作需要很多的对比电路单元和转发电路单元。
      总而言之，CPU和GPU因为最初用来处理的任务就不同，所以设计上有不小的区别。而某些任务和GPU最初用来解决的问题比较相似，所以用GPU来算了。GPU的运算速度取决于雇了多少小学生，CPU的运算
   速度取决于请了多么厉害的教授。教授处理复杂任务的能力是碾压小学生的，但是对于没那么复杂的任务，还是顶不住人多。当然现在的GPU也能做一些稍微复杂的工作了，相当于升级成初中生高中生的
   水平。但还需要CPU来把数据喂到嘴边才能开始干活，究竟还是靠CPU来管的。
  d. 
     什么类型的程序适合在GPU上运行？　　
    （1）计算密集型的程序。所谓计算密集型(Compute-intensive)的程序，就是其大部分运行时间花在了寄存器运算上，寄存器的速度和处理器的速度相当，从寄存器读写数据几乎没有延时。可以做一下
     对比，读内存的延迟大概是几百个时钟周期；读硬盘的速度就不说了，即便是SSD, 也实在是太慢了。　　
     （2）易于并行的程序。GPU其实是一种SIMD(Single Instruction Multiple Data)架构， 他有成百上千个核，每一个核在同一时间最好能做同样的事情。
     
2. OpenGL和WebGL
 OpenGL: 
  ![image](https://raw.githubusercontent.com/suna5511/-/main/1.png)
    是一个关于图形的API的详述定义（specification）[1]，规定了很多函数和其参数返回型，以及要实现的行为和管线操作。具体的实现由硬件厂商完成。所以你可以用同样的
  openGL代码在不同的显卡上跑。（而在不同的操作系统上，在IO层面需要不同的driver，所以你在windows上的和在Mac，linux上的操作系统层面的代码不跨平台。）所以OpenGL由于属于比较High Level，
  效率提不上去也是一个问题。之前shader大战，openGL后知后觉的ARB（Architecture Review board）基本上把openGL自断一臂，输给了directX (windows) [2]苹果也觉得自己慢啊，这也就是为什么
  要搞Metal要从管线和操作系统（macOS，iOS）层面去优化.现在Vulkan出了，会解决openGL很多框架层面的缺陷。其实openGL啊，也是在一定特定历史时期的工程产物。在显示器上，你能绘制一个像素，
  就可以写出一个光栅化的程序。为了加速这个程序你写了很多tricks以及软硬件加速。把这个系统的总结总结，大家都按这个来。后来觉得，嗯，有些操作可以并行，有些操作可以硬件提速，
  搞点vertex buffer或者更多的寄存器，后来中心都移到了显卡。后来有移动端了，又搞一个基于移动端的轻便版本的openGL ES.不断不断细分，演化，进步。
  WebGL:
    a. 
      WebGL 使得在支持HTML 的 canvas 标签的浏览器中，不需要安装任何插件，便可以使用基于 OpenGL ES 2.0 的 API 在 canvas 中进行2D和3D渲染。WebGL程序包括用 JavaScript 写的控制代码，
    以及在图形处理单元（GPU, Graphics Processing Unit）中执行的着色代码（GLSL，注：GLSL为OpenGL着色语言）。WebGL 元素可以和其他 HTML 元素混合使用，并且可以和网页其他部分或者网页
    背景结合起来。WebGL技术标准免去了开发网页专用渲染插件的麻烦，可被用于创建具有复杂3D结构的网站页面，甚至可以用来设计3D网页游戏等等。
    看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光等都是需要借助GLSL ES语法来操作的.
    b.
      看WebGL的背景实际上是JavaScript操作一些OpenGL接口，也就意味着，可能会编写一部分GLSL ES 2.0的代码，没错，你猜对了，WebGL只是绑定了一层，内部的一些核心内容，如着色器，材质，灯光
      等都是需要借助GLSL ES语法来操作的。基于WebGL周边也衍生了众多的第三方库，如开发应用类的Three.js，开发游戏类的Egert.js等，都大大的降低了学习WebGL的成本。
      https://webglreport.com/?v=2  该网站查看自己浏览器是否兼容
      （1）创建WebGL对象  （2）着色器
        
     参考链接


      



